#!/usr/bin/env node

/**
 * Fetch registry data at build time and save it as a TypeScript file.
 * This ensures the indexer has typed registry data without runtime network dependencies.
 */

import { promises as fs } from "fs";
import { join } from "path";
import dotenv from "dotenv";
import fetch from "node-fetch";

dotenv.config({ path: [".env.local", ".env"] });

const envNetwork = process.env["ENVIRONMENT"]
const argNetwork = process.argv.length > 2 ? process.argv.at(-1) : undefined;
const network = argNetwork ?? envNetwork ?? "mainnet";

const {
  REGISTRY_URL = network === "mainnet" ? "https://registry.centrifuge.io/" : "https://registry.testnet.centrifuge.io/",
  IPFS_GATEWAY = "https://ipfs.centrifuge.io/ipfs",
  IPFS_HASH
} = process.env;



const outputDir = join(process.cwd(), "generated");


/**
 * Fetches a single registry the registry from the configured URL
 */
async function fetchRegistry(ipfsHash) {
  // Validate ipfsHash using a regex that matches base58 (CIDv0) or base32 (CIDv1)
  if (!!ipfsHash) {
    const ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44}|b[a-z2-7]{58,})$/i;
    if (!ipfsHashRegex.test(ipfsHash)) {
      throw new Error(`Invalid ipfsHash: ${ipfsHash}`);
    }
  }
  const url = ipfsHash ? join(IPFS_GATEWAY, ipfsHash) : REGISTRY_URL;

  console.log(`Fetching registry from: ${url}`);

  const response = await fetch(url);

  if (!response.ok) {
    throw new Error(`Failed to fetch registry: ${response.statusText}`);
  }

  return await response.json();
}

async function fetchRegistryChain(registryChain = []) {
  if (registryChain.length === 0) registryChain.unshift(await fetchRegistry());
  const registry = registryChain[0]
  const previousHash = registry.previousRegistry ? registry.previousRegistry.ipfsHash : null;
  if (!previousHash) return registryChain;
  const previousRegistry = await fetchRegistry(previousHash)
  registryChain.unshift(previousRegistry)
  if (previousRegistry.previousRegistry) await fetchRegistryChain(registryChain)
  return registryChain
}

/**
 * Generates TypeScript code with the registry data
 */
async function generateTypeScriptRegistry(registry, version) {
  if (version.includes("..")) throw new Error("Invalid version");
  const fileContent = `import type { Registry } from './types';
/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by: pnpm run update-registry
 * Generated at: ${new Date().toISOString()}
 */

export default ${JSON.stringify(registry, null, 2)} as const satisfies Registry
`;
  const filePath = join(outputDir, `registry.v${version}.generated.ts`);
  console.log(`Creating registry.v${version}.generated.ts file...`);
  return fs.writeFile(filePath, fileContent, "utf-8");
}

function generateTypescriptIndex(registryChain, versions) {
  const fileContent = `//
/**
* AUTO-GENERATED FILE - DO NOT EDIT
* Generated by: pnpm run update-registry
* Generated at: ${new Date().toISOString()}
*/

${versions.map((version, index) => `import registry${index} from './registry.v${version}.generated';`).join("\n")}

export default {
${versions.map((version, index) => `  v${version}: registry${index}`).join(",\n")}
} as const
`;
  const filePath = join(outputDir, `index.ts`);
  console.log(`Creating index.ts file...`);
  return fs.writeFile(filePath, fileContent, "utf-8");
}

/**
 * Main execution
 */
async function main() {
  // Remove old generated files before starting new generation
  console.log("Removing old generated files...");
  const files = await fs.readdir(outputDir);
  const genFilePattern = /^registry\.v.*\.generated\.ts$/;
  for (const file of files) {
    if (genFilePattern.test(file) || file === 'index.ts') {
      await fs.unlink(join(outputDir, file));
      console.log(`Removed ${file}`);
    }
  }
  try {
    const registryChain = await fetchRegistryChain(IPFS_HASH);
    const versions = registryChain.map(registry => registry.version.split('-')[0].replace('v', '').replaceAll(".", "_"));
    const _tsContent = await Promise.all(registryChain.map((registry, index) => generateTypeScriptRegistry(registry, versions[index])));
    await generateTypescriptIndex(registryChain, versions);
  } catch (error) {
    console.error("Error fetching registry:", error);
    process.exit(1);
  }
}

main()
  .then(() => {
    console.log("Success");
  })
  .catch((error) => {
    console.error("Error fetching registry:", error);
    process.exit(1);
  });

