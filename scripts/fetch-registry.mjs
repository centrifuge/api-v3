#!/usr/bin/env node

/**
 * Fetch registry data at build time and save it as a TypeScript file.
 * This ensures the indexer has typed registry data without runtime network dependencies.
 */

import { promises as fs } from "fs";
import { join } from "path";
import dotenv from "dotenv";
import fetch from "node-fetch";

dotenv.config({ path: [".env.local", ".env"] });

const {
  REGISTRY_URL = "https://registry.centrifuge.io/",
  REGISTRY_HASH = "QmRSFDjCevk41FB8Dw3DTZFhLo2AFBv8k3AmbBaf7JZq9w",
} = process.env;

const registryHashes = REGISTRY_HASH.split(",").map((hash) => hash.trim());
const outputDir = join(process.cwd(), "generated");


/**
 * Fetches the registry from the configured URL
 */
async function fetchRegistry(hash) {
  const url = REGISTRY_URL + hash;

  console.log(`Fetching registry from: ${url}`);

  const response = await fetch(url);

  if (!response.ok) {
    throw new Error(`Failed to fetch registry: ${response.statusText}`);
  }

  return await response.json();
}

function getDeploymentVersion(registry) {
  const deploymentInfos = Object.values(registry.chains).map(
    (chain) => chain.deploymentInfo
  );
  const deploymentVersions = Array.from(
    new Set(
      deploymentInfos.map(
        (info) => info?.["deploy:protocol"]?.version?.replace(/[^0-9.]/g, "") ?? "3"
      )
    )
  );
  const [version, ...rest] = deploymentVersions;
  if (!version) throw new Error("No deployment version found");
  if (rest.length > 0)
    throw new Error(
      `Multiple deployment versions found: ${deploymentVersions.join(",")}`
    );
  return version;
}

/**
 * Generates TypeScript code with the registry data
 */
async function generateTypeScriptRegistry(registry, version) {
  if (version.includes("..")) throw new Error("Invalid version");
  const fileContent = `import type { Registry } from './types';
/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by: pnpm run update-registry
 * Generated at: ${new Date().toISOString()}
 */

export default ${JSON.stringify(registry, null, 2)} as const satisfies Registry
`;
  const filePath = join(outputDir, `registry.v${version}.generated`);
  return fs.writeFile(filePath, fileContent, "utf-8");
}

function generateTypescriptIndex(registries, versions) {
  const fileContent = `//
/**
* AUTO-GENERATED FILE - DO NOT EDIT
* Generated by: pnpm run update-registry
* Generated at: ${new Date().toISOString()}
*/

${versions.map((version, index) => `import registry${index} from './registry.v${version}.generated';`).join("\n")}

export default {
  ${versions.map((version, index) => `v${version}: registry${index}`).join(",\n")}
} as const
`;
  const filePath = join(outputDir, `index.ts`);
  return fs.writeFile(filePath, fileContent, "utf-8");
}

/**
 * Main execution
 */
async function main() {
  try {
    const registries = await Promise.all(registryHashes.map(hash => fetchRegistry(hash)));
    const versions = registries.map(registry => getDeploymentVersion(registry));
    const _tsContent = await Promise.all(registries.map((registry, index) => generateTypeScriptRegistry(registry, versions[index])));
    await generateTypescriptIndex(registries, versions);
  } catch (error) {
    console.error("Error fetching registry:", error);
    process.exit(1);
  }
}

main()
  .then(() => {
    console.log("Success");
  })
  .catch((error) => {
    console.error("Error fetching registry:", error);
    process.exit(1);
  });

