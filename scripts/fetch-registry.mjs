#!/usr/bin/env node

/**
 * Fetch registry data at build time and save it as a TypeScript file.
 * This ensures the indexer has typed registry data without runtime network dependencies.
 */

import { promises as fs } from "fs";
import { join } from "path";
import dotenv from "dotenv";
import fetch from "node-fetch";

dotenv.config({ path: [".env.local", ".env"] });


const network = process.argv.length > 2 ? process.argv.at(-1) : "mainnet";

const {
  REGISTRY_URL = network === "mainnet" ? "https://registry.centrifuge.io/" : "https://registry.testnet.centrifuge.io/",
  IPFS_GATEWAY = "https://centrifuge.mypinata.cloud/ipfs",
} = process.env;



const outputDir = join(process.cwd(), "generated");


/**
 * Fetches a single registry the registry from the configured URL
 */
async function fetchRegistry(ipfsHash) {
  const url = ipfsHash ? join(IPFS_GATEWAY, ipfsHash) : REGISTRY_URL;

  console.log(`Fetching registry from: ${url}`);

  const response = await fetch(url);

  if (!response.ok) {
    throw new Error(`Failed to fetch registry: ${response.statusText}`);
  }

  return await response.json();
}

async function fetchRegistryChain(registryChain = []) {
  if (registryChain.length === 0) registryChain.unshift(await fetchRegistry());
  const registry = registryChain[0]
  const previousHash = registry.previousRegistry ? registry.previousRegistry.ipfsHash : null;
  const previousRegistry = await fetchRegistry(previousHash)
  registryChain.unshift(previousRegistry)
  if (previousRegistry.previousRegistry) await fetchRegistryChain(registryChain)
  return registryChain
}

/**
 * Generates TypeScript code with the registry data
 */
async function generateTypeScriptRegistry(registry, version) {
  if (version.includes("..")) throw new Error("Invalid version");
  const fileContent = `import type { Registry } from './types';
/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by: pnpm run update-registry
 * Generated at: ${new Date().toISOString()}
 */

export default ${JSON.stringify(registry, null, 2)} as const satisfies Registry
`;
  const filePath = join(outputDir, `registry.v${version}.generated.ts`);
  return fs.writeFile(filePath, fileContent, "utf-8");
}

function generateTypescriptIndex(registryChain, versions) {
  const fileContent = `//
/**
* AUTO-GENERATED FILE - DO NOT EDIT
* Generated by: pnpm run update-registry
* Generated at: ${new Date().toISOString()}
*/

${versions.map((version, index) => `import registry${index} from './registry.v${version}.generated';`).join("\n")}

export default {
${versions.map((version, index) => `  v${version}: registry${index}`).join(",\n")}
} as const
`;
  const filePath = join(outputDir, `index.ts`);
  return fs.writeFile(filePath, fileContent, "utf-8");
}

/**
 * Main execution
 */
async function main() {
  try {
    const registryChain = await fetchRegistryChain();
    const versions = registryChain.map(registry => registry.version.split('-')[0].replace('v', '').replaceAll(".", "_"));
    const _tsContent = await Promise.all(registryChain.map((registry, index) => generateTypeScriptRegistry(registry, versions[index])));
    await generateTypescriptIndex(registryChain, versions);
  } catch (error) {
    console.error("Error fetching registry:", error);
    process.exit(1);
  }
}

main()
  .then(() => {
    console.log("Success");
  })
  .catch((error) => {
    console.error("Error fetching registry:", error);
    process.exit(1);
  });

