#!/usr/bin/env tsx

/**
 * Fetch registry data at build time and save it as a TypeScript file.
 * This ensures the indexer has typed registry data without runtime network dependencies.
 */

import { promises as fs } from "fs";
import { join } from "path";
import dotenv from "dotenv";
import fetch from "node-fetch";
import { AbiItem } from "viem";

dotenv.config({ path: [".env.local", ".env"] });

const {
  REGISTRY_URL = "https://registry.centrifuge.io/",
  REGISTRY_HASH = "QmRSFDjCevk41FB8Dw3DTZFhLo2AFBv8k3AmbBaf7JZq9w",
} = process.env;

const registryHashes = REGISTRY_HASH.split(",").map((hash) => hash.trim());
const outputDir = join(process.cwd(), "generated");

interface DeploymentInfo {
  "deploy:protocol"?: {
    version?: string;
  };
}

interface Registry {
  abis: Record<string, AbiItem[]>;
  chains: {
    mainnet: Record<string, unknown> & { deploymentInfo?: DeploymentInfo };
    testnet: Record<string, unknown> & { deploymentInfo?: DeploymentInfo };
  };
}

/**
 * Fetches the registry from the configured URL
 */
async function fetchRegistry(hash: string): Promise<Registry> {
  const url = REGISTRY_URL + hash;

  console.log(`Fetching registry from: ${url}`);

  const response = await fetch(url);

  if (!response.ok) {
    throw new Error(`Failed to fetch registry: ${response.statusText}`);
  }

  return (await response.json()) as Registry;
}

function getDeploymentVersion(registry: Registry) {
  const deploymentInfos = Object.values(registry.chains).map(
    (chain) => chain.deploymentInfo
  );
  const deploymentVersions = Array.from(
    new Set(
      deploymentInfos.map(
        (info) => info?.["deploy:protocol"]?.version?.replace(/[^0-9.]/g, "") ?? "3"
      )
    )
  );
  const [version, ...rest] = deploymentVersions;
  if (!version) throw new Error("No deployment version found");
  if (rest.length > 0)
    throw new Error(
      `Multiple deployment versions found: ${deploymentVersions.join(",")}`
    );
  return version;
}

/**
 * Generates TypeScript code with the registry data
 */
async function generateTypeScriptRegistry(registry: Registry, version: string) {
  const fileContent = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by: pnpm run update-registry
 * Generated at: ${new Date().toISOString()}
 */

export default ${JSON.stringify(registry, null, 2)} as const
`;
  const filePath = join(outputDir, `registry.generated.v${version}`);
  return fs.writeFile(filePath, fileContent, "utf-8");
}

function generateTypescriptIndex(registries: Registry[], versions: string[]) {
  const fileContent = `/**
* AUTO-GENERATED FILE - DO NOT EDIT
* Generated by: pnpm run update-registry
* Generated at: ${new Date().toISOString()}
*/

${versions.map((version, index) => `import registry${index} from './registry.generated.v${version}';`).join("\n")}

export default {
  ${versions.map((version, index) => `v${version}: registry${index}`).join(",\n")}
} as const
`;
  const filePath = join(outputDir, `index.ts`);
  return fs.writeFile(filePath, fileContent, "utf-8");
}

/**
 * Main execution
 */
async function main() {
  try {
    const registries = await Promise.all(registryHashes.map(hash => fetchRegistry(hash)));
    const versions = registries.map(registry => getDeploymentVersion(registry));
    const _tsContent = await Promise.all(registries.map((registry, index) => generateTypeScriptRegistry(registry, versions[index]!)));
    await generateTypescriptIndex(registries, versions);
  } catch (error) {
    console.error("Error fetching registry:", error);
    process.exit(1);
  }
}

main()
  .then(() => {
    console.log("Success");
  })
  .catch((error) => {
    console.error("Error fetching registry:", error);
    process.exit(1);
  });
